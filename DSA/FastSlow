//Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.


class Node {
  constructor(value, next=null){
    this.value = value;
    this.next = next;
  }
}

const has_cycle = function(head) {
  // TODO: Write your code here
  return false
}

head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
head.next.next.next.next.next = new Node(6)
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)




class Node {
  constructor(value, next = null) {
    this.value = value;
    this.next = next;
  }
}

function has_cycle(head) {
  let slow = head,
    fast = head;
  while( fast !== null && fast.next !== null) {
    fast = fast.next.next;
    slow = slow.next;
    if(slow === fast){
        return true;
    }
}
return false
  }

  head = new Node(1)
  head.next = new Node(2)
  head.next.next = new Node(3)
  head.next.next.next = new Node(4)
  head.next.next.next.next = new Node(5)
  head.next.next.next.next.next = new Node(6)
  console.log(`LinkedList has cycle: ${has_cycle(head)}`)
  
  head.next.next.next.next.next = head.next.next
  console.log(`LinkedList has cycle: ${has_cycle(head)}`)
  
  head.next.next.next.next.next = head.next.next.next
  console.log(`LinkedList has cycle: ${has_cycle(head)}`)


//   Similar Problems #

// Problem 1: Given the head of a LinkedList with a cycle, find the length of the cycle.

// Solution: We can use the above solution to find the cycle in the LinkedList. Once the fast and slow pointers meet, we can save the slow pointer and iterate the whole cycle with another pointer until we see the slow pointer again to find the length of the cycle.

// Here is what our algorithm will look like:



class Node {
  constructor(value, next = null) {
    this.value = value;
    this.next = next;
  }
}


function find_cycle_length(head) {
  let slow = head,
  fast = head;
  while( fast !== null && fast.next !== null) {
    fast = fast.next.next;
    slow = slow.next;
    if(slow === fast){
        return calculate_cycle_length(slow)
    }
}
    return 0
}

function calculate_cycle_length(slow){
    let current = slow,
    cycle_length = 0;
    while(true){
        current = current.next;
        cycle_length += 1;
        if(current === slow) {
            break;
        }
    }
    return cycle_length;
}

head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
head.next.next.next.next.next = new Node(6)
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)




// Problem Statement #

// Given the head of a Singly LinkedList that contains a cycle, write a function to find the starting node of the cycle.

class Node {
  constructor(value, next=null){
    this.value = value;
    this.next = next;
  }
}

const find_cycle_start = function(head){
  // TODO: Write your code here
  return head;

}


head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
head.next.next.next.next.next = new Node(6)
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)



//soln
class Node {
    constructor(value, next = null) {
      this.value = value;
      this.next = next;
    }
  }
  
  
  function find_cycle_length(head) {
    let slow = head,
    fast = head;
    while( fast !== null && fast.next !== null) {
      fast = fast.next.next;
      slow = slow.next;
      if(slow === fast){
          return calculate_cycle_length(slow)
      }
  }
      return 0
  }
  
  function find_cyclic_start(head){
      cycle_length = 0;

      let slow = head;
      fast = head;

       while( fast !== null && fast.next !== null) {
      fast = fast.next.next;
      slow = slow.next;
      if(slow === fast){
          cycle_length = calculate_cycle_length(slow)
          break;
      }
  }
      return find_start(head, cycle_length)
  }


  function calculate_cycle_length(slow){
      let current = slow,
      cycle_length = 0;
      while(true){
          current = current.next;
          cycle_length += 1;
          if(current === slow) {
              break;
          }
      }
      return cycle_length;
  }


  function find_start(head, cycle_length){
    let pointer1 = head,
    pointer2 = head;

    while(cycle_length > 0){
        ponter2 = pointer2.next;
        cycle_length -= 1;
    }

    while(pointer1 !== pointer2){
        ponter1 = pointer1.next;
        pointer2 = pointer2.next
    }

    return pointer1;
}


head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
head.next.next.next.next.next = new Node(6)
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)







// Problem Statement #

// Any number will be called a happy number if, after repeatedly replacing it with a number equal to the sum of the square of all of its digits, leads us to number ‘1’. All other (not-happy) numbers will never reach ‘1’. Instead, they will be stuck in a cycle of numbers which does not include ‘1’.

function find_happy_number(num) {
    let slow = num,
        fast = num;
    while (true) {
        slow = find_square_sum(slow); // move one step
        fast = find_square_sum(find_square_sum(fast)); // move two steps
        if (slow === fast) { // found the cycle
            break;
        }
    }
    return slow === 1
}

function find_square_sum(num){
    let sum = 0;
    while((num > 0)){
        digit = number % 10;
        sum += digit * digit;
        num = Math.floor(num/10)
    }
    return sum
}

console.log(find_happy_number(23))



// Problem Statement #

// Given the head of a Singly LinkedList, write a method to return the middle node of the LinkedList.

// If the total number of nodes in the LinkedList is even, return the second middle node.





class Node {
  constructor(value, next=null){
    this.value = value;
    this.next = next;
  }
}

const find_middle_of_linked_list = function(head) {
  // TODO: Write your code here
  return head;
}

head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)


function find_middle_of_linked_list(head) {
    let slow = head,
      fast = head;
    while( fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
  }
  return slow
    }

    head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)

head.next.next.next.next.next = head.next.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)